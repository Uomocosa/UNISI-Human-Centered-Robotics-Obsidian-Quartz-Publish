- ***Exercise 1***: ^exercise-1
	- Compute the [[Notes & Images/HCR - Grasp Matrix|Grasp Matrix]] in the object frame for the following grasps.<br>Give the dimension of the Jacobian Matrix.
	- For a general grasp (not the one in the figure) write the main equations of the grasp an in your words describe the sequence of operations that you have to follow to apply a given wrench $W_c$ through the contact force.
	- How do you compute the contact force?
	- What's the role of the nullspace of the grasp matrix?
- ***Exercise 2***: ^exercise-2
	- Describe in your words the role of the [[HCR - Cinematica Diretta di un Manipolatore Robotico (Lecture)|direct kinematics]] and of the [[HCR - Cinematica Diretta di un Manipolatore Robotico (Lecture)|Jacobian]] in [[HCR - Haptics (Lecture)|computer haptics]].
	- In other terms describe in your words how a robot can play a role of '[[HCR - Haptics (Lecture)|haptic display]]'
- ***Exercise 3***: ^exercise-3
	- Describe the process (or algorithm) of triangulation to compute the normal for the haptic feedback in a triangle of a triangular mesh.
----
- ***Solutions***: #NOT_SURE_ABOUT_THIS `I did them myself, nobody else corrected it` 
	- (*[[#^exercise-1|Exercise 1]]*)<br>First we define the **contact points** $d_1$ and $d_2$ with respect to the center of the object/the reference system of the object, so:$$d_1 = \left[1 ,\ 0,\ 0\right] \kern15px, \kern45px d_2 = \left[-1 ,\ 0,\ 0\right]$$Then from these we define their respective [[HCR - Screw Matrix|screw matricies]], so:$$\begin{array}{c} S(d_1) = \left[\begin{array}{c} 0 & 0 & 0 \\ 0 & 0 & -1 \\ 0 & 1 & 0 \end{array}\right] \\[5px] S(d_2) = \left[\begin{array}{c} 0 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & -1 & 0\end{array}\right] \end{array}$$Then we define the [[HCR - Grasp Matrix (Lecture)|grasp matrix]]:$$G = \left[\begin{array}{c} 1 & 0 & 0 & 1 & 0 & 0 \\ 0 & 1 & 0 & 0 & 1 & 0 \\ 0 & 0 & 1 & 0 & 0 & 1 \\ 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & -1 & 0 & 0 & 1 \\ 0 & 1 & 0 & 0 & -1 & 0 \\    \end{array}\right]$$Then we define the [[HCR - Grasping (Lecture)|hand Jacobian]], since we don't have the dimensions of the **arms**, I'll define them like so:$$\vec b_1 = \left[\begin{array}{c} 0 \\ b_{1y} \\ 0  \end{array}\right] \kern15px , \kern45px \vec b_2 = \left[\begin{array}{c} b_{2x} \\ b_{2y} \\ 0  \end{array}\right] \kern15px , \kern45px \vec b_3 = \left[\begin{array}{c} 0 \\ b_{3y} \\ 0  \end{array}\right]$$As we can see the $z$ axis is $0$ for all of them, then like for the grasp matric we define the [[HCR - Screw Matrix|screw matrices]] for all of them:$$\begin{array}{l} S(\vec b_1)  = \left[\begin{array}{c} 0 & 0 & b_{1y} \\ 0 & 0 & 0 \\ -b_{1y} & 0 & 0 \\ \end{array}\right] \\[5px]  S(\vec b_2)  = \left[\begin{array}{c} 0 & 0 & b_{2y} \\ 0 & 0 & -b_{2x} \\ -b_{2y} & b_{2x} & 0 \\ \end{array}\right] \\[5px]  S(\vec b_1)  = \left[\begin{array}{c} 0 & 0 & b_{3y} \\ 0 & 0 & 0 \\ -b_{3y} & 0 & 0 \\ \end{array}\right] \end{array}$$Then we'll constract the complete [[HCR - Grasping (Lecture)|hand Jacobian]]:$$J^{\tiny T} = \left[\begin{array}{c} 0 & 0 & b_{1y} & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 \\ -b_{1y} & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & b_{2y} \\ 0 & 0 & 0 & 0 & 0 & -b_{2x} \\ 0 & 0 & 0 & -b_{2y} & b_{2x} & 0 \\ 0 & 0 & 0 & 0 & 0 & b_{3y} \\ 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & -b_{3y} & 0 & 0 \end{array}\right]$$The **complete hand jacobian**, will have dimensions: $[9 \times 6]$, if we were to reduce it, so by not considering the $z$ component for the torques, since we can say that for construction of the manipulator $\tau_x$ and $\tau_y$ will be always $0$, so if we write the complete formula:$$\left[\begin{array}{c} \tau_{1x} \\ \tau_{1y} \\ \tau_{1z} \\ \tau_{2x} \\ \tau_{2y} \\ \tau_{2z} \\ \tau_{3x} \\ \tau_{3y} \\ \tau_{3z}  \end{array}\right] = \left[\begin{array}{c} 0 & 0 & b_{1y} & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 \\ -b_{1y} & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & b_{2y} \\ 0 & 0 & 0 & 0 & 0 & -b_{2x} \\ 0 & 0 & 0 & -b_{2y} & b_{2x} & 0 \\ 0 & 0 & 0 & 0 & 0 & b_{3y} \\ 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & -b_{3y} & 0 & 0 \end{array}\right] \left[\begin{array}{c} F_{1x} \\ F_{1y} \\ F_{1z} \\ F_{2x} \\ F_{2y} \\ F_{2z} \end{array}\right] $$We can reduce this formula, by considering $\tau_{1x} = \tau_{1y} = \tau_{2x} = \tau_{2y} = \tau_{3x} = \tau_{3y} = 0$, so:$$\left[\begin{array}{c} \tau_{1z} \\ \tau_{2z} \\ \tau_{3z} \end{array}\right] = \left[\begin{array}{c} -b_{1y} & 0 & 0 & 0 & 0 & 0  \\ 0 & 0 & 0 & -b_{2y} & b_{2x} & 0 \\ 0 & 0 & 0 & -b_{3y} & 0 & 0 \end{array}\right] \left[\begin{array}{c} F_{1x} \\ F_{1y} \\ F_{1z} \\ F_{2x} \\ F_{2y} \\ F_{2z} \end{array}\right] $$Now the **reduced** [[HCR - Grasping (Lecture)|hand Jacobian]] has dimensions $[3 \times 6]$.<br>More generarly, given a general grasp, so we are talking about $n_c$ contact points (so $d_1 ,\ \ldots ,\ d_{n_c}$). %%with $n_j$ joints (so $b_1 ,\ \ldots ,\ b_{n_j}$)%%<br>We want to apply a wrench $W_{\tiny C}$ through the contact force $F_{\tiny C}$:<br>***1.*** We define the [[HCR - Screw Matrix|screw matrices]] for all of them, so:<br>$S(d_1) ,\ \ldots ,\ S(d_{n_c})$ and $S(b_1) ,\ \ldots ,\ S(b_{n_j})$<br>***2.*** We calculate the [[HCR - Grasp Matrix • Matrice di Grasp|grasp matrix]] $G$:$$G = \left[\begin{array}{c} I & \ldots & I \\ S(d_1) & \ldots & S(d_{n_c}) \end{array}\right]$$<br>***3.*** We resolve the following formula to obtain the contact force to apply:$$F_{\tiny C} = G^{\#}\cdot W_{\tiny C} + N(G) \cdot \xi$$Dove:<br>**•** $G^{\#}$ indica la [[HCR - Pseudoinversa di una Matrice|pseudoinversa]] di $G$.<br>**•** $N(G)$ è il [[HCR - Kernel • Nullspace|nullspace]] di $G$.<br>We need to say however that for these forces to apply, they need to be inside the [[HCR - Friction Cone|friction cone]], unless we are talking about an [[HCR - Enveloping Grasping|enveloping grasp]], so that for $N(G) = 0$ then the system has only has only one solution menaning that the forces need to be inside the friction cone, otherwise we would not have a grasp, and the object would slip, and with $N(G) = 0$ we cannot change the friction cone, in any way.<br>While for $N(G) \neq 0$ we can change the $\xi$ vector such that the **normal forces** with respect to the surface/plane where the contat points are, increase and so does the friction cone, so for $N(G) \neq 0$ we can ensure the grasp.<br>Also we have said that if $G$ has [[HCR - Rango Massimo|max rank]] (more specifically $\text{rank} = 6$) then we have a grasp that can move and rotate the object in every direction, since we can always find an $F_{\tiny C}$ such that:$$W_{C} = G \cdot F_{\tiny C}$$ #NOT_SURE_ABOUT_THIS `If the matrix was a square one the proof could be simple, since a square matrix with max rank is always invertible, but in this case we are talking about a rectangular matrix`
	- (*[[#^exercise-2|Exercise 2]]*)<br>Let's start with how we can describe a complete system for an haptic display, meaning a robot that takes in input the force we provide as users, and returns in output another force that we (users) feel, for example: *we could feel a force with opposite direction to the one we gave as input*.<br>To do so, we have seen the simplified design of a simple haptic process:<br>![[Pasted image 20240904122251.png]]<br>And we have defined "in mathematic terms" how it can do so:$$\text{input} \rightarrow k \cdot \Delta x \rightarrow F \rightarrow \tau \rightarrow \text{output}$$So the user moves the **end-effector**, the sensors measure this force, then we pass the data to a force response, such that we can decide/calculate how the end-effector should respond to this movement, then we pass this $F_e$ to the control algorithm such that it can calculate the correct **torque** for each **joint**.<br>To calculate the correct **torques**, we can use the [[HCR - Cinematica Diretta di un Manipolatore Robotico (Lecture)|Jacobian matrix]], defined as:$$J = \left[\begin{array}{c} {\large{\partial F_x \over \partial \alpha}} & {\large{\partial F_x \over \partial \beta}} & \ldots \\  {\large{\partial F_y \over \partial \alpha}} & {\large{\partial F_y \over \partial \beta}} & \ldots \\ {\large{\partial F_z \over \partial \alpha}} & {\large{\partial F_z \over \partial \beta}} & \ldots\end{array}\right]$$Where:<br>**•** $\alpha,\ \beta,\ \ldots$ : are the angels of each **joint** (considering only **revolutionary joints**).<br>**•** $F_x$ is the function that returns the $x$-position of the **end-effector**, given the variuos **linkers** lenght ($\rho_1,\ \rho_2,\ \ldots$) and angles ($\alpha,\ \beta,\ \ldots$), this is the role of the **direct kinematics**, meaning that if we know the angles of the joints and linkers' lenght, we can always found the position of the **end-effector**. <br>**•** $F_y ,\ F_z$ instead are for the $y$ and $z$ position of the **end-effector**, respectively.<br>Then using this matrix we can calculate the **torques**, simply by applying the following formula:$$\tau = J^{\tiny T} F_e$$
	- (*[[#^exercise-3|Exercise 3]]*)<br>Given a triangular mesh of an object, we need first to identify the **bounding box**, so the smallest box that contains the triangle we want to 'study':<br>So we start by checking it the **end-effector** represented by an avatar vector $x_h$ is inside or outside the "starting box", if it is outside, then we are certain that there is no contact, otherwise if $x_h$ is inside the bounding box, we consider a more restrictive (a smaller) box, and check again, we continue to shrink and check this way untill we find that: $x_h$ is not inside the current bounding box, so the end effector does not touch the object, or we have reached the minum bounding box.<br>Also we can calculate the minum distance between $x_h$ and $x_p$ (a point of the triangle/plane):<br>***1.*** We start by defining the plane we are working with, with its coefficients:<br>$(a \ b \ c)$ and $d$, such that:$$(a \ b \ c)\cdot x_p = d$$***2.*** Then we find $x_p$ such that the distance between $x_p$ and $x_h$ is minimum so:$$x_p : \min\left(\sqrt{(x_p - x_h)^{\tiny T}(x_p - x_h)}\right)$$***3.*** Then using the distance $D = \overline{x_h \kern5px x_p}$, we can say that if $D \gt 0$ then the **end-effector** does not touch the plane, $D \lt 0$ the **end-effector** is "inside"/is touching the object.<br>***4.*** We can use the value of the distance $D$ as a way to give a proper response to the user, like changin the output force of the manipualtor if we have an higher value $D$.
----
##### Original File
![[Pasted image 20220303090958.png]]
